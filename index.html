<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="styles.css">
    <title>Maze game</title>
</head>
<body>
<div class="btn-div">
    <button class="play-btn" id="playButton" style="height:50px;" onclick="getAccel()"><h2>Play game!</h2></button>
</div>
<canvas id="myCanvas" width="500" height="500" style="border:1px solid #000000;">
    Your browser does not support the HTML canvas tag.
</canvas>
<div></div>

<script>

    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');

    const ball = {
        centerX: canvas.width / 2,
        centerY: canvas.height / 2,
        radius: 10,
        fillColor: 'red',
    };

    function drawBall() {
        ctx.fillStyle = ball.fillColor;
        ctx.beginPath();
        ctx.arc(ball.centerX, ball.centerY, ball.radius, 0, 2 * Math.PI);
        ctx.fill();
    }

    const obstacleColour = [0, 0, 0];

    function drawBoundary() {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 200;
        ctx.fillStyle = 'white'
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.fill();
    }

    function drawCenterRectangle() {
        const rectHeight = 40;
        const rectWidth = canvas.width - 120;
        const rectX = (canvas.width - rectWidth) / 2;
        const rectY = (canvas.height - rectHeight) / 2;
        ctx.fillStyle = 'white';
        ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
    }

    function drawMaze() {
        drawBoundary();
        drawCenterRectangle();
        drawBall();
    }

    function checkIfCollide(accelX, accelY) {
        let collisionX = 0;
        let collisionY = 0;
        let pixelCount = 0;

        for (let angle = 0; angle < 360; angle += 10) {
            const xCoordinate = ball.centerX + (ball.radius) * Math.cos(angle * (Math.PI / 180));
            const yCoordinate = ball.centerY + (ball.radius) * Math.sin(angle * (Math.PI / 180));
            const checkColour = ctx.getImageData(xCoordinate - 0.5, yCoordinate - 0.5, 1, 1).data.slice(0, 3);

            if (checkColour.every((value, index) => value === obstacleColour[index])) {
                collisionX += xCoordinate;
                collisionY += yCoordinate;
                pixelCount += 1;
            }
        }

        if (pixelCount > 0) {
            collisionX /= pixelCount;
            collisionY /= pixelCount;
            return { x: collisionX, y: collisionY };
        } else {
            return { x: 0, y: 0 };
        }
    }

    function getAccel() {
        ball.centerX = canvas.width / 2;
        ball.centerY = canvas.height / 2;
        const XScalingFactor = 2;
        const YScalingFactor = 4;
        const maxAccel = 4;
        const minAccel = -4;

        DeviceMotionEvent.requestPermission().then(response => {
            if (response === 'granted') {
                window.addEventListener('devicemotion', (event) => {
                    let accelX = event.accelerationIncludingGravity.x * XScalingFactor;
                    let accelY = -event.accelerationIncludingGravity.y * YScalingFactor;

                    accelX = Math.min(maxAccel, Math.max(minAccel, accelX));
                    accelY = Math.min(maxAccel, Math.max(minAccel, accelY));

                    const collisionAdjust = checkIfCollide(accelX, accelY);

                    const deltaX = ball.centerX - collisionAdjust.x;
                    const deltaY = ball.centerY - collisionAdjust.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const collisionDepth = ball.radius - distance;

                    if (collisionDepth > 0) {
                        const collisionNormalX = deltaX / distance;
                        const collisionNormalY = deltaY / distance;
                        ball.centerX += collisionNormalX * collisionDepth;
                        ball.centerY += collisionNormalY * collisionDepth;
                    } else {
                        ball.centerX += accelX;
                        ball.centerY += accelY;
                    }

                    drawMaze();
                });
            }
        });
    }
    drawMaze();
</script>
</body>
</html>
